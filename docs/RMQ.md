# 总结
- 单调队列和线段树的区别
    - 单调队列是求k区间内的代表元素,max(x1,...,xk)
    - 线段树是求k区间内，多个元素共同体现的东西f(x1,x2,x3...)
    - 显然线段树是可以退化，完成单调队列的工作。但同时单调栈时间复杂度比线段树低
- 树状数组和前缀和得区别
    - 首先树状数组可以完成前缀和的所有操作，他们的查询操作也类似
    - 但是前缀和单点修改速度为O(n)，比如求第i位之前小于等于nums[i]的个数,1,2,3,2,4, 求到第4位的时候需要重新计算一遍前缀和,也就是维护的时间复杂度变成了O(qn)
- 树状数组和线段树的区别
    - 树状数组与前缀和类似，每个bit[i]保存的是前缀信息，如果要求(l,r]，则f(l,r)与bit[r]和bit[l]之间的关系是可定义的。如求和f(l,r)=bit[r]-bit[l]；异或和f(l,r)=bit[r] xor bit[l]。但是对于最大值，没法通过f(l,r)=g(bit[r],bit[l])获得
    - 首先线段树可以满足树状数组的任何功能，其次对于求最值线段树可以通过f(l,r)=max(tree[l,mid],tree[mid+1,r])求得
前缀和
----
- 作用：统计区间和
单调栈
----
性质
- 本质是找每一个元素第一个比它小(大)的元素
模版
```
// 保存的是数组下标，因为要记录每个数字的后的最大值，而数字可能重复，下标不会重复
while(stack.size()>0&&key<nums[stack.top()]){//也可以通过在栈头加入一个最小的值放置益出
    ans[stack.top()]=key;
    stack.pop();
}
stack.push(key);
```
- 例题：
    - 给你一个序列，返回每个位置后第一个小于它的值
        - 朴素解法：每个位置向后遍历查找第一个小于它的值$O(N^2)$
    - [给你一个条形图，问你相邻截取面积最大是多少](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
        - 若以i为头截取，则截取到第一个高小于它的高的时候停止
单调队列
----
性质
- 本质是维护n数组中长度为k的区间的最值
算法实现:遍历区间，以递增为例子
实现
- 队头保存的永远是最值；所以想维护最小值则递增，否则递减
- 与单调栈不同，单调队列是一个双端队列；
- 应为需要直到当前元素的下标判别是否出界，所以保存的是下标
```c++
\\保存当前区间段最值(队头)
\\去尾；
\\去头
while(que.size()>0&&nums[que.back()]<nums[i] ){
    que.pop_back();
}
que.push_back(i);
if(i-que.front()>k)que.pop_front();
```
线段树
----
对于这样一个问题：q次询问，查找l，r区间内的最值。q,n规模接近
1. 如果维护所有区间$n^2$个，则可以O(q)的时间找出,更新需要$O(n^2)$, 总的时间复杂度为$O(n^2)$
2. 一起区间都不维护，则要O(qn)的时间找出,跟新需要O(1), 总的时间复杂度为$O(qn)$
而自然会想到将两种方法均衡下，使得查询和跟新时间接近
    - 假设在2的基础上多维护(1,2),(3,4)...。则区间查询次数降低一半，区间跟新多维护n/2
按照上面的方法，将区间划分成一个树，则查询次数和更新次数都为深度，此时复杂度为 O(qlogn)
```模版
 vector<int> tree;

    void update(int o, int l, int r, int i, int val) {
        if (l == r) {
            tree[o] = val;
            return;
        }
        int m = (l + r) / 2;
        if (i <= m) update(o * 2, l, m, i, val);
        else update(o * 2 + 1, m + 1, r, i, val);
        tree[o] = max(tree[o * 2], tree[o * 2 + 1]);//修改区间操作
    }
    /*
        返回区间 [L,R] 内的最大值
        o几号区间 l r 迭代区间，L R为查询区间
    */
    int query(int o, int l, int r, int L, int R) { 
        if (L <= l && r <= R) return tree[o];
        int res = 0;
        int m = (l + r) / 2;
        /*
        如果l，r和L，R区间没交集则没必要查下去了，等号取一边就行了
        */
        if (L <= m) res = query(o * 2, l, m, L, R);
        if (R > m) res = max(res, query(o * 2 + 1, m + 1, r, L, R));//修改区间操作
        return res;
    }
```
树状数组
----
- 在线段树里将区间平均的划分成一个完全二叉树，而树状数组则巧妙利用二进制中的关系划分成一个即不平均也不完全的二叉树
    - 二进制方便计算
    - 不平均则减少了结点个数
- 思路：对于求区间1-10的和，将10写成二进制形状1010，那么1010=1000+0010，也即是说求区间1-10可以写成求前0010区间+0010前的1000区间；而标记前0010区间只需要写成1010就表示在1010在个区间内的前2个区间。也就是说每个下标维护(x-lowbit(x),x]的区间
    - 完整性：显然数组中每个点至少保存当前结点信息，也就是数据树组可以保存所有信息
    - 如何查询保证不重叠:每个点保存(i-lowbix(i),i]的信息，那么只需要迭代求(1-lowbit(i)-lowbit(1-lowbit(i),1-lowbit]，直到左边为0即可。
    - 查询的复杂度：由上式可知最坏的情况下为O(logn) ，平均为O((1+logn)/2) 相比线段树啥的快了一倍
    - 如何进行跟新：假设对于具体点00101 如何进行跟新？
        - 显然树状数组中每个值保存的都是该点及前面的信息，所以只需要考虑后面那个包含
        - 对于下标i=00101010，要想k包含则需要: $k-lowbit \lt i and k \gt i \rightarrow i \in (k-lowbit(k),k]$, 两种情况
            1. 01000000 高位有且仅有一个1
            2. 00101010, 00101100,00101000,00110000 前几位相同后某位不同且为1，之后全0
        - 从上式可以看出每个父区间都是i+lowbit(i)
- ⚠️
    - c[x] 是包括x的区间
    - 树状数组中0不保存任何信息
- 模版
```c++
 vector<int>cnt;
    int MAX;
    int lowbit(int x){
        return x&(-x);
    }
    int query(int x){
        if(x>0){
            return cnt[x]+query(x-lowbit(x));//修改区间操作
        }
        return 0;
    }
    void update(int x){
        if(x<MAX){
            cnt[x]++;//单点修改
            update(x+lowbit(x));
        }
        return ;
    }
```
- 例题
    - 求逆序对：    
        - 分析：对于第i位需要求(nums[i],max]的个数，此时时间复杂度与max相关
            - 普通的树状数组记录的是前缀信息，如果要记录后缀信息，只需要将数据reverse即可
            - 如何将数据等比例缩小到整数，使得相对大小不变--》排序
            - 树状数组求的是nums[i]的闭区间，所以需要nums[i]-1
