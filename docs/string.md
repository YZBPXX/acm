马拉车
----
> 与KMP相似，例如 1,2,4,2,5,2,4,2,5。
> 如果已经直到以5为中心的回文串为 2,3,2,5,2,3,2
> 那么以3为中心的回文串，那么左右两边的3回文串前面部分必然相等

综上所诉，令右边3的位置为i左边为j对称点5为c
    - 如果i不在c的范围内，初始化i的边界为0
    - 如果i在c的范围内,
        - 如果i的回文串边界小于c的边界的话 那么i的边界映射过来就是j的边界
            - 因为在以i，j为中心的串在该范围内相等
        - 如果i的回文串边界大于等于c的边界的话 那么j的边界只能定位到c的边界
            - 因为多余的地方不相等，没办法比较
一些细节
    - $j = 2 \times c - j$
    - 为了有中心点需要在所有空隙中插入#, 求插入后的位置(以1为初始下标）：$id = 2 \times index$ 
    - 为了比较时不判断是否到达两端，可以在两端插入不可能出现的字符，让他自动退出
    - 以下这种实现方法，p[t] 的回文半径比真实的大1,这样下次可以直接比较（如next数组也是只想匹配的下一个）
```
void manacher(){
    data[0]='&';
    data[2*n+1]='#';
    data[2*n+2]='$';
    for(int i=1;i<=n;i++){
        data[2*i-1]='#';
        data[2*i]=s[i-1];
    }
   for(int t=1;t<=2*n;t++){
       if(t<=mid+p[mid])p[t]=min(p[(mid<<1)-t],mid+p[mid]-t);
       while(data[t-p[t]]==data[t+p[t]])p[t]++;
       if(p[t]+t>p[mid]+mid) mid=t; 
   }
}
```
